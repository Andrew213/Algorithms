// 1. Констнантная сложность - О(1) - где нет циклов, рекурсий, перебора
// 2. Логарифмическая сложность - O(log(n)) - где делится массив. Пример - бинарный поиск
// 3. Линейная сложность - O(n) - обычный перебор всех элементов. Сложность возрастает с увеличением длинны
// 4. Линейно логарифмическая - О(n*log(n)) - когда в цикле есть логарифмическая сложность.
//Например - нахождение пересечений массивов. бинарный поиск внутри цикла.
// 5. Квадратичная O(n^2) - цикл в цикле.
// 6. Экспоненциальная сложность O(2^n) - возникает в рекурсивных алгоритмах, где на каждом шаге количество обрабатываемых данных уменьшается менее чем вдвое.
// Пример – нахождение n-го числа Фибоначчи.
// 7. Факториальная сложность O(n!) - пример брутфорс.
// возникает в комбинаторных задачах, где перебирают варианты вида «все со всеми» и проверяют соответствие условию.

function permutations(arr: any[], perm: any[] = [], result: any[] = []) {
  // если элементов не осталось - возвращаем текущую перестановку
  if (arr.length === 0) {
    result.push(perm);
  } else {
    for (let i = 0; i < arr.length; i++) {
      // создаем копию массива
      const copy = arr.slice();
      // убираем из него текущий элемент
      const elem = copy.splice(i, 1);
      // запускаем алгоритм заново на копии,
      // добавив текущий элемент в массив с перестановками
      permutations(copy, perm.concat(elem), result);
    }
  }

  return result;
}

console.log(permutations(["a", "b", "c", "d"]));
